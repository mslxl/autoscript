@strict:true
@debug:true
@precompile:true

class Unit{
    fn toString(): str
}
obj Unit{

}

obj Calc{
    // arguments without type would be dynamic
    fn add(a :dynamic, b):num{
        ret a+b;
    }
}

fn main(cmdlet1:str, cmdlet2:num, cmtlet3: bool = false, cmdlet4:char, cmdlet5:float){
    let curry_func = Calc.add(cmdlet1)
    StdIO.print(curry_func(cmdlet2))
}

class A from B {

}

// ---- enhance ----
// generic would not allow use dynamic!!

struct Student<T>{
    let backpack:T
}

trait Functor<T,R>{
    fn map(func: (T)->R)
}

