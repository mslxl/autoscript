use crate::ast::{Expr, Opcode, Loc, UnaryOpcode};

grammar();
match {
    r"[ \t\r]" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}else{
    _
}

pub Program = ComposableExpr;


Float  : f64    = r"[0-9]+((\.[0-9]+)([eE][0-9]+)?|([eE][0-9]+))"   => <>.parse().unwrap();
Int    : i64    = r"[0-9]+"                                         => <>.parse().unwrap();
Str    : String = <s:r#""[^"]*""#>                                  => s[1..s.len()-1].to_string();
Char   : char   = r"'.'"                                            => <>.chars().nth(1).unwrap();
BoolTrue:bool        = "true"                                            => true;
BoolFalse:bool       = "false"                                           => false;
Bool   : bool   = {
    BoolTrue,
    BoolFalse,
};
Identifier:String= r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_owned();

NecN = r"[\n\r]+[\n\r\s]*";
OptN = {
    <NecN>,
    => ""
};


// --------
// if expr
// ----------

IfE1: Box<Expr> = {
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfE1> "else" <el:IfE1> => Box::new(Expr::IfExpr{
        loc: Loc::new(l, el.loc().right),
        cond: cond,
        then: then,
        el: el,
    }),
    <expr:ComposableExpr> => expr,
};

IfE2: Box<Expr> = {
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfExpr> => Box::new(Expr::IfExpr{
        loc: Loc::new(l, then.loc().right),
        cond: cond,
        then: then,
        el: Box::new(Expr::Unit),
    }),
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfE1> "else" <el:IfE2> =>Box::new(Expr::IfExpr{
        loc: Loc::new(l, el.loc().right),
        cond: cond,
        then: then,
        el: el,
    }),
};


IfExpr: Box<Expr> = {
    IfE1,
    IfE2,
}

ComposableExpr:Box<Expr> = {
     <l:@L>"{" OptN <mut es:Stmt*> <e:Expr?> "}" <r:@R> => {
        let stmts = match e {
            None => es,
            Some(x) => {
                es.push(x);
                es
            }
        };
        Box::new(Expr::ComposableExpr(Loc::new(l,r),stmts))
     }
};

Stmt: Box<Expr> = {
    <Expr> NecN
};

Expr = {
    LogicOrExpr,
    TermExpr,
};

// ---------
// Expr
// ---------


LogicOrExpr: Box<Expr> = {
    <lhs:LogicOrExpr> <op:LogicOrExprOp> OptN <rhs:LogicAndExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    LogicAndExpr,
};

LogicOrExprOp : Opcode ={
    "||"    => Opcode::Or,
    "or"    => Opcode::Or,
};


LogicAndExpr: Box<Expr> = {
    <lhs:LogicAndExpr> <op:LogicAndExprOp> OptN <rhs:CompareExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    CompareExpr,
};

LogicAndExprOp: Opcode = {
    "&&"  => Opcode::And,
    "and" => Opcode::And,
}


CompareExpr: Box<Expr> = {
    <lhs:TermExpr> <op:CompareExprOp> OptN <rhs:TermExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    <lhs:TermExpr> <lop:CompareExprOp> OptN <mhs:TermExpr> <rop:CompareExprOp> OptN <rhs:TermExpr> => {
        Box::new(Expr::OpExpr(
            Loc::merge(&lhs.loc(), &rhs.loc()),
            Box::new(Expr::OpExpr(
                Loc::merge(&lhs.loc(), &mhs.loc()),
                lhs,
                lop,
                mhs.clone(),
            )),
            Opcode::And,
            Box::new(Expr::OpExpr(
                Loc::merge(&mhs.loc(), &rhs.loc()),
                mhs.clone(),
                rop,
                rhs,
            )),
        ))
    },
    <l:@L> <b:Bool> <r:@R>  => Box::new(Expr::Bool(b, Loc::new(l,r))),
};

CompareExprOp: Opcode = {
    "=="    => Opcode::Eq,
    ">"     => Opcode::Gt,
    "<"     => Opcode::Lt,
    ">="    => Opcode::Ge,
    "<="    => Opcode::Le,
};


TermExpr: Box<Expr> = {
    <lhs:TermExpr> <op:TermExprOp> OptN <rhs:FactorExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    FactorExpr,
};


TermExprOp: Opcode = {
    "+"     => Opcode::Add,
    "-"     => Opcode::Sub,
    "+="     => Opcode::AddAssign,
    "-="     => Opcode::SubAssign,
};


FactorExpr: Box<Expr> = {
    <lhs:FactorExpr> <op:FactorOp> OptN <rhs:BitExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    BitExpr,
};

FactorOp: Opcode = {
    "*"     => Opcode::Mul,
    "/"     => Opcode::Div,
    "%"     => Opcode::Mod,
    "**"    => Opcode::Pow,

    "*="    => Opcode::MulAssign,
    "/="    => Opcode::DivAssign,
    "%="    => Opcode::ModAssign,
};


BitExpr: Box<Expr> = {
    <lhs:BitExpr>  <op:BitOp> OptN <rhs:UnaryExpr> => Box::new(Expr::OpExpr(Loc::merge(&lhs.loc(), &rhs.loc()), lhs, op, rhs)),
    UnaryExpr,
};

BitOp:  Opcode = {
    "<<" => Opcode::Lsh,
    ">>" => Opcode::Rsh,
    ">>>"=> Opcode::RshUnsigned,
    "&"  => Opcode::BitAnd,
    "|"  => Opcode::BitOr,
    "^"  => Opcode::BitXor,
};


UnaryExpr: Box<Expr> = {
    <op:UnaryOp> <e:SuffixExpr> => Box::new(Expr::UnaryOpExpr(e.loc().map_l(|l|l-1),op,e)),
    SuffixExpr,
};

UnaryOp: UnaryOpcode = {
    "!" => UnaryOpcode::Not,
    "-" => UnaryOpcode::Neg,
    "+" => UnaryOpcode::Pos,
    "~" => UnaryOpcode::BitNot,

};

SuffixExpr: Box<Expr> = {
    <e:BaseExpr> <op:SuffixOp> => Box::new(Expr::UnaryOpExpr(e.loc().map_r(|r|r+2),op,e)),
    BaseExpr,
};

SuffixOp: UnaryOpcode = {
    "++" => UnaryOpcode::Inc,
    "--" => UnaryOpcode::Dec,
};

BaseExpr: Box<Expr> = {
    <l:@L> <i:Int> <r:@R>   => Box::new(Expr::Int(i, Loc::new(l,r))),
    <l:@L> <f:Float> <r:@R> => Box::new(Expr::Float(f, Loc::new(l,r))),
    <l:@L> <s:Str> <r:@R>   => Box::new(Expr::Str(s, Loc::new(l,r))),
    <l:@L> <c:Char> <r:@R>  => Box::new(Expr::Char(c, Loc::new(l,r))),
    <l:@L> <i:Identifier> <r:@R> => Box::new(Expr::Identifier(i, Loc::new(l,r))),
    "(" <Expr> ")",
    <IfExpr>
};

