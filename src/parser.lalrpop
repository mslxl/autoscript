use crate::ast::{
    Expr,
    UnitExpr,
    IntConstExpr,
    FloatConstExpr,
    BoolConstExpr,
    IdentifierExpr,
    StrConstExpr,
    CharConstExpr,
    OpExpr,
    UnaryOpExpr,
    ComposableExpr,
    IfExpr,
    WhileExpr,
    TriOpExpr,
    Opcode,
    UnaryOpcode,
    ReturnExpr,
    ImportStmt,
    FuncCallExpr,

    FuncDecl,
    TypeRef,
    VarDeclExpr,
    TopLevelScopeDecl
};

grammar();
match {
    r"[ \t\r]" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}else{
    _
}

pub Program = <TopScopeElement*>;

TopScopeElement:TopLevelScopeDecl = {
    <f:FuncDef> => TopLevelScopeDecl::FuncDecl(f),
    <v:VarDeclExpr> => TopLevelScopeDecl::VarDecl(v),
    <i:Import> => TopLevelScopeDecl::Import(i),
}


Float  : f64    = r"[0-9]+((\.[0-9]+)([eE][0-9]+)?|([eE][0-9]+))"   => <>.parse().unwrap();
Int    : i64    = r"[0-9]+"                                         => <>.parse().unwrap();
Str    : String = <s:r#""[^"]*""#>                                  => s[1..s.len()-1].to_string();
Char   : char   = r"'.'"                                            => <>.chars().nth(1).unwrap();
BoolTrue:bool        = "true"                                            => true;
BoolFalse:bool       = "false"                                           => false;
Bool   : bool   = {
    BoolTrue,
    BoolFalse,
};
Identifier:String= r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_owned();

NecN = r"[\n\r]+[\n\r\s]*";
OptN = {
    <NecN>,
    => ""
};

// macro util
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// function def

TypedArgs: (String, TypeRef, Option<Box<dyn Expr>>) ={
    <id:Identifier> ":" <t:Identifier> => (id, TypeRef(t), None),
    <id:Identifier> ":" <t:Identifier> "=" <v:Expr> => (id, TypeRef(t), Some(v)),
}



FuncDef: Box<FuncDecl> = {
    <l:@L> "fn" <id:Identifier> "(" <args:Comma<TypedArgs>> ")" <block:ComposableExpr> OptN => {
        Box::new(FuncDecl::new(l,block.loc().right,id, "unit".to_string(), args, block))
    },
    <l:@L> "fn" <id:Identifier> "(" <args:Comma<TypedArgs>> ")" "->" <return_type:Identifier> <block:ComposableExpr> OptN => {
        Box::new(FuncDecl::new(l,block.loc().right,id, return_type, args, block))
    }
}

// var decl

VarDeclExpr: Box<VarDeclExpr> = {
    <l:@L> "val" <id:Identifier> <t:(":" <Identifier>)?> "=" <exp:Expr> => {
        Box::new(VarDeclExpr::new(l, exp.loc().right, id, None,false, exp))
    },
    <l:@L> "var" <id:Identifier> <t:(":" <Identifier>)?> "=" <exp:Expr> => {
        Box::new(VarDeclExpr::new(l, exp.loc().right, id, None,true, exp))
    }
}


// --------
// if expr
// ----------


IfE1: Box<dyn Expr> = {
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfE1> "else" <el:IfE1> => Box::new(IfExpr::new(cond,then,el)),
    <expr:ComposableExpr> => expr,
};

IfE2: Box<dyn Expr> = {
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfExpr> =>     {
        let end_loc = then.loc();
        Box::new(IfExpr::new(cond, then, Box::new(UnitExpr::new(end_loc.right))))
    },
    <l:@L> "if"  <cond:LogicOrExpr>  <then:IfE1> "else" <el:IfE2> => Box::new(IfExpr::new(cond, then, el)),
};

ControlFlow = {
    IfExpr,
    WhileExpr,
    RepeatExpr,
    LoopExpr
}


IfExpr: Box<dyn Expr> = {
    IfE1,
    IfE2,
};

WhileExpr: Box<dyn Expr> = {
    <l:@L> "while" <cond:LogicOrExpr> <does:ComposableExpr> => Box::new(WhileExpr::new(cond, does)),
};

RepeatExpr: Box<dyn Expr> = {
    <l:@L> "until" <cond:LogicOrExpr> <does:ComposableExpr>  => {
        Box::new(WhileExpr::new(Box::new(UnaryOpExpr::new(cond, UnaryOpcode::Not)), does))

    },
};

LoopExpr: Box<dyn Expr> = {
    <l:@L> "loop" <does:ComposableExpr> => Box::new(WhileExpr::new(Box::new(BoolConstExpr::new_true(l,l)), does)),
}

ComposableExpr:Box<ComposableExpr> = {
     <l:@L>"{" OptN <mut es:Stmt*> <e:Expr?> "}" <r:@R> => {
        let stmts = match e {
            None => es,
            Some(x) => {
                es.push(x);
                es
            }
        };
        Box::new(ComposableExpr::new(l,r,stmts))
     }
};

Stmt: Box<dyn Expr> = {
    <Expr> NecN,
    ReturnStmt
};

Expr = {
    LogicOrExpr,
    TermExpr,
    <t:VarDeclExpr> => t as Box<dyn Expr>,
};

// ------
// return
// ------

ReturnStmt: Box<ReturnExpr> = {
    <l:@L> "return" <e:Expr?> <r:@R> NecN => Box::new(ReturnExpr::new(l,r, e))
}

// -------
// import
// -------

Import: Box<ImportStmt> = {
    <l:@L> "import" <id:Identifier> <r:@R> NecN => Box::new(ImportStmt::new(l,r,id))
}


// ---------
// Expr
// ---------

FuncCallExpr: Box<FuncCallExpr> = {
    <l:@L> <id:Identifier> "(" <args:Comma<Expr>> ")" <r:@R> => Box::new(FuncCallExpr::new(l,r,id,args))
}


LogicOrExpr: Box<dyn Expr> = {
    <lhs:LogicOrExpr> <op:LogicOrExprOp> OptN <rhs:LogicAndExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    LogicAndExpr,
};

LogicOrExprOp : Opcode ={
    "||"    => Opcode::Or,
    "or"    => Opcode::Or,
};


LogicAndExpr: Box<dyn Expr> = {
    <lhs:LogicAndExpr> <op:LogicAndExprOp> OptN <rhs:CompareExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    CompareExpr,
};

LogicAndExprOp: Opcode = {
    "&&"  => Opcode::And,
    "and" => Opcode::And,
}


CompareExpr: Box<dyn Expr> = {
    <lhs:TermExpr> <op:CompareExprOp> OptN <rhs:TermExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    <lhs:TermExpr> <lop:CompareExprOp> OptN <mhs:TermExpr> <rop:CompareExprOp> OptN <rhs:TermExpr> => {
        Box::new(TriOpExpr::new(lhs, lop, mhs, rop, rhs))
    },
    <l:@L> <b:Bool> <r:@R>  => Box::new(BoolConstExpr::new(l,r, b)),
};

CompareExprOp: Opcode = {
    "=="    => Opcode::Eq,
    "!="    => Opcode::Ne,
    ">"     => Opcode::Gt,
    "<"     => Opcode::Lt,
    ">="    => Opcode::Ge,
    "<="    => Opcode::Le,
};


TermExpr: Box<dyn Expr> = {
    <lhs:TermExpr> <op:TermExprOp> OptN <rhs:FactorExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    FactorExpr,
};


TermExprOp: Opcode = {
    "+"     => Opcode::Add,
    "-"     => Opcode::Sub,
    "+="     => Opcode::AddAssign,
    "-="     => Opcode::SubAssign,
};


FactorExpr: Box<dyn Expr> = {
    <lhs:FactorExpr> <op:FactorOp> OptN <rhs:BitExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    BitExpr,
};

FactorOp: Opcode = {
    "*"     => Opcode::Mul,
    "/"     => Opcode::Div,
    "%"     => Opcode::Mod,
    "**"    => Opcode::Pow,

    "*="    => Opcode::MulAssign,
    "/="    => Opcode::DivAssign,
    "%="    => Opcode::ModAssign,
};


BitExpr: Box<dyn Expr> = {
    <lhs:BitExpr>  <op:BitOp> OptN <rhs:UnaryExpr> => Box::new(OpExpr::new(lhs, rhs, op)),
    UnaryExpr,
};

BitOp:  Opcode = {
    "<<" => Opcode::Lsh,
    ">>" => Opcode::Rsh,
    ">>>"=> Opcode::RshUnsigned,
    "&"  => Opcode::BitAnd,
    "|"  => Opcode::BitOr,
    "^"  => Opcode::BitXor,
};


UnaryExpr: Box<dyn Expr> = {
    <op:UnaryOp> <e:SuffixExpr> => Box::new(UnaryOpExpr::new(e,op)),
    SuffixExpr,
};

UnaryOp: UnaryOpcode = {
    "!" => UnaryOpcode::Not,
    "-" => UnaryOpcode::Neg,
    "+" => UnaryOpcode::Pos,
    "~" => UnaryOpcode::BitNot,

};

SuffixExpr: Box<dyn Expr> = {
    <e:BaseExpr> <op:SuffixOp> => Box::new(UnaryOpExpr::new(e,op)),
    BaseExpr,
};

SuffixOp: UnaryOpcode = {
    "++" => UnaryOpcode::Inc,
    "--" => UnaryOpcode::Dec,
};

BaseExpr: Box<dyn Expr> = {
    <l:@L> <i:Int> <r:@R>   => Box::new(IntConstExpr::new(l,r,i)),
    <l:@L> <f:Float> <r:@R> => Box::new(FloatConstExpr::new(l,r,f)),
    <l:@L> <s:Str> <r:@R>   => Box::new(StrConstExpr::new(l,r,s)),
    <l:@L> <c:Char> <r:@R>  => Box::new(CharConstExpr::new(l,r,c)),
    <l:@L> <i:Identifier> <r:@R> => Box::new(IdentifierExpr::new(l,r,i)),
    "(" <Expr> ")",
    ControlFlow,
    FuncCallExpr,
};

