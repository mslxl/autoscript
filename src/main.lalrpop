use std::str::FromStr;
use aalang::ast::{Expr, Opcode};

grammar;


// lexer

Float  : f64 = <s:r"[0-9]+((\.[0-9]+)([eE][0-9]+)?|([eE][0-9]+))">      => f64::from_str(s).unwrap();
Int    : i64 = <s:r"[0-9]+">                                            => i64::from_str(s).unwrap();
Str    : String = <s:r#""[^"]*""#>                                      => s[1..s.len()-1].to_string();
BoolTrue = "true";
BoolFalse = "false";

Identifer       = r"[a-zA-Z_][a-zA-Z0-9_]*";


KwdFunctionDef  = "fn";
KwdStructDef    = "class";

KwdModPublic    = "pub";
KwdModPrivate   = "priv";

KwdLazy         = "lazy";

KwdVar          = "var";
KwdVal          = "val";

KwdModule       = "mod";
KwdImport       = "import";

KwdTypeInt      = "int";
KwdTypeFloat    = "float";

KwdAnd          = "and";
KwdOr           = "or";

KwdPatternMatch = "match";


// parser

pub S = PrimaryExpr;

PrimaryExpr = LogicOrExpr;

LogicOrExpr: Box<Expr> = {
    LogicOrExpr LogicOrExprOp LogicAndExpr => Box::new(Expr::OpExpr(<>)),
    LogicAndExpr,
};

LogicOrExprOp : Opcode ={
    "||"    => Opcode::Or,
    "or"    => Opcode::Or,
};

LogicAndExpr: Box<Expr> = {
    LogicAndExpr LogicAndExprOp LogicBaseExpr => Box::new(Expr::OpExpr(<>)),
    LogicBaseExpr,
};

LogicAndExprOp: Opcode = {
    "&&"    => Opcode::And,
    KwdAnd  => Opcode::And,
};


LogicBaseExpr: Box<Expr> = {
    LogicBaseExpr LogicBaseExprOp TermExpr => Box::new(Expr::OpExpr(<>)),
    TermExpr,
};

LogicBaseExprOp: Opcode = {
    "=="    => Opcode::Eq,
    ">"     => Opcode::Gt,
    "<"     => Opcode::Lt,
    ">="    => Opcode::Ge,
    "<="    => Opcode::Le,
};


TermExpr: Box<Expr> = {
    TermExpr TermExprOp FactorExpr => Box::new(Expr::OpExpr(<>)),
    FactorExpr,
};


TermExprOp: Opcode = {
    "+"     => Opcode::Add,
    "-"     => Opcode::Sub,
    "+="     => Opcode::AddAssign,
    "-="     => Opcode::SubAssign,
};



FactorExpr: Box<Expr> = {
    FactorExpr FactorOp FactorShiftOpExpr => Box::new(Expr::OpExpr(<>)),
    FactorShiftOpExpr,
};

FactorOp: Opcode = {
    "*"     => Opcode::Mul,
    "/"     => Opcode::Div,
    "%"     => Opcode::Mod,
    "**"    => Opcode::Pow,

    "*="    => Opcode::MulAssign,
    "/="    => Opcode::DivAssign,
    "%="    => Opcode::ModAssign,
};


FactorShiftOpExpr: Box<Expr> = {
    FactorShiftOpExpr FactorShiftOp FactorUnaryOpExpr => Box::new(Expr::OpExpr(<>)),
    FactorUnaryOpExpr,
};

FactorShiftOp: Opcode = {
    "<<" => Opcode::Lsh,
    ">>" => Opcode::Rsh,
    ">>>"=> Opcode::RshUnsigned,
    "&"  => Opcode::BitAnd,
    "|"  => Opcode::BitOr,
    "^"  => Opcode::BitXor,
};

FactorUnaryOpExpr: Box<Expr> = {
    FactorUnaryOp FactorBase => Box::new(Expr::UnaryOpExpr(<>)),
    FactorBase,
};

FactorUnaryOp: Opcode = {
    "~" => Opcode::BitNot,
    "!" => Opcode::Not,
    "-" => Opcode::Neg,
}

FactorBase: Box<Expr> = {
    Float           => Box::new(Expr::Float(<>)),
    Int             => Box::new(Expr::Int(<>)),
    Str             => Box::new(Expr::Str(<>)),
    <s:Identifer>   => Box::new(Expr::Identifer(s.to_owned())),
    BoolTrue        => Box::new(Expr::Bool(true)),
    BoolFalse       => Box::new(Expr::Bool(false)),
    "(" <PrimaryExpr> ")",
};