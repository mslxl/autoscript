use std::str::FromStr;
use aalang::ast::{Expr, Opcode, FunctionDef, Block, Stmt, Decl, ProgramElem};

grammar;


// lexer

Float  : f64    = <s:r"[0-9]+((\.[0-9]+)([eE][0-9]+)?|([eE][0-9]+))">   => f64::from_str(s).unwrap();
Int    : i64    = <s:r"[0-9]+">                                         => i64::from_str(s).unwrap();
Str    : String = <s:r#""[^"]*""#>                                      => s[1..s.len()-1].to_string();
BoolTrue        = "true";
BoolFalse       = "false";

Identifer:String= <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_owned();


KwdFunctionDef  = "fn";
KwdStructDef    = "class";
KwdRVDef        = "->";
KwdRet          = "return";

KwdIf           = "if";
KwdElseIf       = "elif";
KwdElse         = "else";

KwdRepeat       = "repeat";
KwdUntil        = "until";

KwdWhile        = "while";
KwdFor          = "for";

KwdIn           = "in";

KwdModPublic    = "pub";
KwdModPrivate   = "priv";

KwdLazy         = "lazy";
KwdPure         = "pure";

KwdVar          = "var";
KwdVal          = "val";

KwdModule       = "mod";
KwdImport       = "import";

KwdTypeInt      = "int";
KwdTypeFloat    = "float";
KwdTypeUnit     = "unit";
KwdTypeAuto     = "auto";

KwdAnd          = "and";
KwdOr           = "or";

KwdPatternMatch = "match";


// parser

//---------------
// macros tools
//---------------
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// ---------
// defition
// ---------
pub AALang = ProgramElems;


ProgramElems: Vec<ProgramElem> = <ProgramElem*>;

ProgramElem: ProgramElem = {
    <FuncDef> => ProgramElem::FuncDef(<>),
    <VarDecl> => ProgramElem::VarDef(<>),
    <ValDecl> => ProgramElem::VarDef(<>),
    KwdImport <i:Identifer> ";" => ProgramElem::Import(i),
};

// -----------
// misc
// -----------

PrimaryExpr = {
    <LogicOrExpr>,
    <IfExpr>,
};


// -------------
// if-elif-else
// -------------

MinIfBr: (Box<Expr>, Box<Expr>) ={
    KwdIf "(" <cond:LogicOrExpr> ")" <b:Block> => (cond, Box::new(Expr::BlockExpr(b))),
};

MinElifBr: (Box<Expr>, Box<Expr>) = KwdElseIf "(" <cond:LogicOrExpr> ")" <b:Block> => (cond, Box::new(Expr::BlockExpr(b)));

MinElseBr: Box<Expr> = KwdElse <Block> => Box::new(Expr::BlockExpr(<>));


IfExpr: Box<Expr> = <m:MinIfBr> <eifs:MinElifBr*> <e:MinElseBr?> => {
    Box::new(Expr::If{
        main:m,
        elif: eifs,
        els: e,
    })
};

// -----------
// repeat-until
// -----------

RepeatStmt: Stmt = {
    KwdRepeat <b:Block> KwdUntil "(" <e:PrimaryExpr> ")" ";" => Stmt::RepeatUntilStmt(e, b),
};

// -------
// while
// -------
WhileStmt: Stmt = {
    KwdWhile "(" <e:PrimaryExpr> ")" <b:Block>  => Stmt::WhileStmt(<>),
};

// -------
// for-each
// -------

ForEachStmt: Stmt = {
    KwdFor "(" <id:Identifer> KwdIn <e:PrimaryExpr> ")" <b:Block>   => Stmt::ForEachStmt(<>),
};

// --------
// function
// --------

TypeIdentifer:String = {
    Identifer,
    <KwdTypeInt>    => String::from(<>),
    <KwdTypeFloat>  => String::from(<>),
    <KwdTypeUnit>   => String::from(<>),
    <KwdTypeAuto>   => String::from(<>),
};

FuncDef: FunctionDef = {
    KwdFunctionDef <name:Identifer> "(" ")" <b:Block> => {
        FunctionDef{
            return_type: String::from("unit"),
            name:name,
            block: b
        }
    },
    KwdFunctionDef <name:Identifer> "(" ")" KwdRVDef <rv:TypeIdentifer> <b:Block> => {
        FunctionDef{
            return_type: rv,
            name:name,
            block: b
        }
    },
};

Block: Block = {
    "{" <stmts:Stmt*> "}" => Block{<>},
};

//---------
// Stmt
//---------
Stmt = {
    RetStmt,
    AssignStmt,
    ExprStmt,
    VarDeclStmt,
    ValDeclStmt,
    RepeatStmt,
    WhileStmt,
    ForEachStmt,
};

RetStmt: Stmt = {
    KwdRet <expr:PrimaryExpr?> ";" => Stmt::ReturnStmt(<>),
};

ExprStmt: Stmt = {
    <expr:LogicOrExpr> ";"  => Stmt::ExprStmt(expr),
    <expr:IfExpr>           => Stmt::ExprStmt(expr),
};

VarDeclStmt: Stmt = <VarDecl> => Stmt::DeclStmt(<>);
ValDeclStmt: Stmt = <ValDecl> => Stmt::DeclStmt(<>);


VarDecl: Decl = <d:DeclStmt<KwdVar>> => Decl::Var{
    name:d.0,
    value: d.1,
    decl_type: d.2,
};

ValDecl: Decl = <d:DeclStmt<KwdVal>> => Decl::Val{
    name:d.0,
    value: d.1,
    decl_type: d.2,
};

DeclStmt<K> : (String, Box<Expr>, String) = {
    K <var:Identifer> ":" <t:TypeIdentifer> "=" <expr:PrimaryExpr> ";"=> (var, expr, t),
    K <var:Identifer> "=" <expr:PrimaryExpr> ";" => (var, expr, String::from("auto")),
};

AssignStmt: Stmt = {
    <var:Identifer> "=" <expr:PrimaryExpr> ";" => Stmt::AssignStmt{
        name: var,
        value: expr,
    },
};

//-----------------
// symbol expr below 
//-----------------

LogicOrExpr: Box<Expr> = {
    LogicOrExpr LogicOrExprOp LogicAndExpr => Box::new(Expr::OpExpr(<>)),
    LogicAndExpr,
};

LogicOrExprOp : Opcode ={
    "||"    => Opcode::Or,
    "or"    => Opcode::Or,
};

LogicAndExpr: Box<Expr> = {
    LogicAndExpr LogicAndExprOp LogicBaseExpr => Box::new(Expr::OpExpr(<>)),
    LogicBaseExpr,
};

LogicAndExprOp: Opcode = {
    "&&"    => Opcode::And,
    KwdAnd  => Opcode::And,
};


LogicBaseExpr: Box<Expr> = {
    LogicBaseExpr LogicBaseExprOp TermExpr => Box::new(Expr::OpExpr(<>)),
    TermExpr,
};

LogicBaseExprOp: Opcode = {
    "=="    => Opcode::Eq,
    ">"     => Opcode::Gt,
    "<"     => Opcode::Lt,
    ">="    => Opcode::Ge,
    "<="    => Opcode::Le,
};


TermExpr: Box<Expr> = {
    TermExpr TermExprOp FactorExpr => Box::new(Expr::OpExpr(<>)),
    FactorExpr,
};


TermExprOp: Opcode = {
    "+"     => Opcode::Add,
    "-"     => Opcode::Sub,
    "+="     => Opcode::AddAssign,
    "-="     => Opcode::SubAssign,
};



FactorExpr: Box<Expr> = {
    FactorExpr FactorOp FactorShiftOpExpr => Box::new(Expr::OpExpr(<>)),
    FactorShiftOpExpr,
};

FactorOp: Opcode = {
    "*"     => Opcode::Mul,
    "/"     => Opcode::Div,
    "%"     => Opcode::Mod,
    "**"    => Opcode::Pow,

    "*="    => Opcode::MulAssign,
    "/="    => Opcode::DivAssign,
    "%="    => Opcode::ModAssign,
};


FactorShiftOpExpr: Box<Expr> = {
    FactorShiftOpExpr FactorShiftOp FactorUnaryOpExpr => Box::new(Expr::OpExpr(<>)),
    FactorUnaryOpExpr,
};

FactorShiftOp: Opcode = {
    "<<" => Opcode::Lsh,
    ">>" => Opcode::Rsh,
    ">>>"=> Opcode::RshUnsigned,
    "&"  => Opcode::BitAnd,
    "|"  => Opcode::BitOr,
    "^"  => Opcode::BitXor,
};

FactorUnaryOpExpr: Box<Expr> = {
    FactorUnaryOp FactorBase => Box::new(Expr::UnaryOpExpr(<>)),
    FactorBase,
};

FactorUnaryOp: Opcode = {
    "~" => Opcode::BitNot,
    "!" => Opcode::Not,
    "-" => Opcode::Neg,
}

FactorBase: Box<Expr> = {
    Float           => Box::new(Expr::Float(<>)),
    Int             => Box::new(Expr::Int(<>)),
    Str             => Box::new(Expr::Str(<>)),
    <Identifer>   => Box::new(Expr::Identifer(<>)),
    BoolTrue        => Box::new(Expr::Bool(true)),
    BoolFalse       => Box::new(Expr::Bool(false)),
    "(" <PrimaryExpr> ")",
    <Block>         => Box::new(Expr::BlockExpr(<>)),
};